package main

import (
	"fmt"
	"log"
	"strconv"
	"strings"

	PMFS "github.com/rjboer/PMFS"
	llm "github.com/rjboer/PMFS/pmfs/llm"
	gemini "github.com/rjboer/PMFS/pmfs/llm/gemini"
)

// This example demonstrates a full flow using Gemini to analyze a document,
// storing the returned requirements, asking multiple role-specific questions
// about each requirement, and evaluating them against quality gates. After the
// Gemini client is configured, requirement methods can be used directly without
// passing the client to interact or gates packages.
func main() {
	// Stub the Gemini client so the example runs without external calls.
	stub := gemini.ClientFunc{
		AnalyzeAttachmentFunc: func(path string) ([]gemini.Requirement, error) {
			return []gemini.Requirement{
				{ID: 1, Name: "Login", Description: "Users shall log in with email and password."},
				{ID: 2, Name: "Logout", Description: "Users shall be able to log out securely."},
			}, nil
		},
		AskFunc: func(prompt string) (string, error) {
			p := strings.ToLower(prompt)
			if strings.Contains(p, "answer yes or no only") {
				return "Yes", nil
			}
			if strings.Contains(p, "given the requirement") {
				return "Yes", nil
			}
			return "stub response", nil
		},
	}
	prev := gemini.SetClient(stub)
	defer gemini.SetClient(prev)

	// Analyze a document to extract potential requirements.
	reqs, err := gemini.AnalyzeAttachment("testdata/spec1.txt")
	if err != nil {
		log.Fatalf("analyze: %v", err)
	}
	if len(reqs) == 0 {
		log.Fatal("no requirements returned")
	}

	// Store the requirements in a project structure.
	prj := PMFS.ProjectType{}
	for _, r := range reqs {
		prj.D.PotentialRequirements = append(prj.D.PotentialRequirements, PMFS.FromGemini(r))
	}

	roles := []string{"product_manager", "qa_lead", "security_privacy_officer"}

	// Ask each role about every requirement and evaluate quality gates.
	for i := range prj.D.PotentialRequirements {
		r := &prj.D.PotentialRequirements[i]
		fmt.Printf("Requirement %d: %s - %s\n", i+1, r.Name, r.Description)
		id := strconv.Itoa(i + 1)
		for _, role := range roles {
			pass, follow, _ := r.Analyse(role, id)
			fmt.Printf("  %s agrees? %v\n", role, pass)
			if follow != "" {
				fmt.Printf("    Follow-up: %s\n", follow)
			}
		}

		_ = r.EvaluateGates([]string{"clarity-form-1", "duplicate-1"})
		for _, gr := range r.GateResults {
			fmt.Printf("  Gate %s passed? %v\n", gr.Gate.ID, gr.Pass)
		}
	}
}
